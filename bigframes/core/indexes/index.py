# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An index based on a single column."""

from __future__ import annotations

import typing
from typing import Callable, Tuple

import pandas as pd

import bigframes.core.blocks as blocks
import bigframes.core.indexes.implicitjoiner as implicitjoiner
import bigframes.core.joins as joins


class Index:
    def __init__(self, data: blocks.BlockHolder):
        self._data = data

    @property
    def name(self) -> typing.Optional[str]:
        """Get the name of the Index."""
        # This introduces a level of indirection over Ibis to allow for more
        # accurate pandas behavior (such as allowing for unnamed or
        # non-uniquely named objects) without breaking SQL generation.
        return self._data._get_block()._index_labels[0]

    @name.setter
    def name(self, value: blocks.Label) -> typing.Optional[str]:
        """Set the name of the Index."""
        # This introduces a level of indirection over Ibis to allow for more
        # accurate pandas behavior (such as allowing for unnamed or
        # non-uniquely named objects) without breaking SQL generation.
        return self._data._set_block(self._data._get_block().with_index_labels([value]))

    def compute(self) -> pd.Index:
        return IndexValue(self._data._get_block()).compute()


class IndexValue(implicitjoiner.ImplicitJoiner):
    """An index based on a single column."""

    # TODO(swast): Handle more than 1 index column, possibly in a separate
    # MultiIndex class.
    # TODO(swast): Include ordering here?
    def __init__(self, block: blocks.Block):
        super().__init__(block)

    def __repr__(self) -> str:
        """Converts an Index to a string."""
        # TODO(swast): Add a timeout here? If the query is taking a long time,
        # maybe we just print the job metadata that we have so far?
        # TODO(swast): Avoid downloading the whole index by using job
        # metadata, like we do with DataFrame.
        preview = self.compute()
        return repr(preview)

    def compute(self) -> pd.Index:
        """Executes deferred operations and downloads the results."""
        # Project down to only the index column. So the query can be cached to visualize other data.
        index_column = self._block.index_columns[0]
        expr = self._expr.projection([self._expr.get_any_column(index_column)])
        df: pd.DataFrame = (
            expr.start_query()
            .result()
            .to_dataframe(
                bool_dtype=pd.BooleanDtype(),
                int_dtype=pd.Int64Dtype(),
                float_dtype=pd.Float64Dtype(),
                string_dtype=pd.StringDtype(storage="pyarrow"),
            )
        )
        df.set_index(index_column)
        index = df.index
        index.name = self._block._index_labels[0]
        return index

    def join(
        self, other: implicitjoiner.ImplicitJoiner, *, how="left", sort=False
    ) -> Tuple[IndexValue, Tuple[Callable[[str], str], Callable[[str], str]],]:
        if not isinstance(other, IndexValue):
            # TODO(swast): We need to improve this error message to be more
            # actionable for the user. For example, it's possible they
            # could call set_index and try again to resolve this error.
            raise ValueError(
                "Can't mixed objects with explicit Index and ImpliedJoiner"
            )

        # TODO(swast): Support cross-joins (requires reindexing).
        if how not in {"outer", "left", "right", "inner"}:
            raise NotImplementedError(
                "Only how='outer','left','right','inner' currently supported"
            )

        (
            combined_expr,
            joined_index_col_name,
            (get_column_left, get_column_right),
        ) = joins.join_by_column(
            self._block.expr,
            self._block.index_columns[0],
            other._block.expr,
            other._block.index_columns[0],
            how=how,
            sort=sort,
        )
        # Drop original indices from each side. and used the coalesced combination generated by the join.
        left_indices = [get_column_left(col_id) for col_id in self._block.index_columns]
        right_indices = [
            get_column_right(col_id) for col_id in other._block.index_columns
        ]
        combined_expr = combined_expr.drop_columns(left_indices).drop_columns(
            right_indices
        )
        block = blocks.Block(
            combined_expr,
            index_columns=[joined_index_col_name],
            column_labels=[*self._block.column_labels, *other._block.column_labels],
            index_labels=[self.name] if self.name == other.name else [None],
        )
        return (
            typing.cast(IndexValue, block.index),
            (get_column_left, get_column_right),
        )
